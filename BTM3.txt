from ._anvil_designer import ThuatToanSapXepTemplate
import anvil.server


class ThuatToanSapXep(ThuatToanSapXepTemplate):
    def __init__(self, **properties):
        # Set Form properties and Data Bindings.
        self.init_components(**properties)

    def text_box_1_pressed_enter(self, **event_args):
        """This method is called when the user presses Enter in this text box"""
        self.button_1_click()

    def button_1_click(self, **event_args):
        """This method is called when the button is clicked"""
        numbers_input = self.text_box_1.text.strip()
        algorithm = self.text_box_2.text.strip().lower()

        try:
            numbers = [int(num) for num in numbers_input.split()]
        except ValueError:
            self.label_1.text = "Đầu vào không hợp lệ. Vui lòng nhập lại dãy số nguyên."
            return

        sorted_numbers = self.sort_numbers(numbers, algorithm)
        self.label_1.text = ', '.join(map(str, sorted_numbers))

    def sort_numbers(self, numbers, algorithm):
        """Hàm thực hiện sắp xếp dãy số nguyên theo thuật toán chỉ định"""
        if algorithm == 'insertion sort':
            return self.insertion_sort(numbers)
        elif algorithm == 'selection sort':
            return self.selection_sort(numbers)
        elif algorithm == 'bubble sort':
            return self.bubble_sort(numbers)
        elif algorithm == 'merge sort':
            return self.merge_sort(numbers)
        else:
            raise ValueError("Invalid sorting algorithm")

    def insertion_sort(self, numbers):
        """Thuật toán Insertion Sort"""
        for i in range(1, len(numbers)):
            key = numbers[i]
            j = i - 1
            while j >= 0 and numbers[j] > key:
                numbers[j + 1] = numbers[j]
                j -= 1
            numbers[j + 1] = key
        return numbers

    def selection_sort(self, numbers):
        """Thuật toán Selection Sort"""
        for i in range(len(numbers)):
            min_idx = i
            for j in range(i + 1, len(numbers)):
                if numbers[j] < numbers[min_idx]:
                    min_idx = j
            numbers[i], numbers[min_idx] = numbers[min_idx], numbers[i]
        return numbers

    def bubble_sort(self, numbers):
        """Thuật toán Bubble Sort"""
        n = len(numbers)
        for i in range(n - 1):
            for j in range(0, n - i - 1):
                if numbers[j] > numbers[j + 1]:
                    numbers[j], numbers[j + 1] = numbers[j + 1], numbers[j]
        return numbers

    def merge_sort(self, numbers):
        """Thuật toán Merge Sort"""
        if len(numbers) <= 1:
            return numbers
        mid = len(numbers) // 2
        left_half = numbers[:mid]
        right_half = numbers[mid:]
        left_half = self.merge_sort(left_half)
        right_half = self.merge_sort(right_half)
        return self.merge(left_half, right_half)

    def merge(self, left, right):
        merged = []
        left_index = 0
        right_index = 0
        while left_index < len(left) and right_index < len(right):
            if left[left_index] < right[right_index]:
                merged.append(left[left_index])
                left_index += 1
            else:
                merged.append(right[right_index])
                right_index += 1
        merged.extend(left[left_index:])
        merged.extend(right[right_index:])
        return merged